# MySQL & JPA Rules

## Database Naming Conventions
- **Tables**: `snake_case` (e.g., `checklist_instance`, `action_record`)
- **Columns**: `snake_case` (e.g., `created_at`, `user_id`)
- **Foreign Keys**: `fk_{table}_{ref_table}` (optional, but keep naming consistent)
- **Indexes**: `idx_{table}_{column}`

## JPA Entity Rules
- **Primary Key**: Use `Long` type with `@Id @GeneratedValue(strategy = GenerationType.IDENTITY)`.
- **Auditing**: Extend `BaseTimeEntity` for `created_at`, `updated_at` automated handling (`@EntityListeners(AuditingEntityListener.class)`).
- **Relationships**:
  - **Fetch Strategy**: ALWAYS use `FetchType.LAZY` for `@ManyToOne`, `@OneToMany`.
    - *Why*: To prevent N+1 problems and unnecessary loading.
  - **Mapping**: Prefer bidirectional only when necessary. Start with unidirectional.
  - **Cascading**: Use carefully. Prefer explicit save/delete in Service logic over complex cascades unless strictly parent-child lifecycle bound.

## Performance Optimization
- **N+1 Problem**:
  - Use `join fetch` in JPQL Repository methods for reading related entities.
  - Or use `@EntityGraph`.
  - Or use `BatchSize` for collection fetching.
- **Read-Only Transactions**: Ensure `@Transactional(readOnly = true)` is used for read operations to optimize database resources.
- **Bulk Operations**: Use `@Modifying` and `@Query` for bulk updates/deletes to bypass entity state tracking.

## Data Types
- **Boolean**: `TINYINT(1)` maps to `Boolean`.
- **Enum**: Use `@Enumerated(EnumType.STRING)`. Never use `ORDINAL`.
- **DateTime**: Use `LocalDateTime` (maps to `DATETIME` or `TIMESTAMP`).

## Schema Management
- Do not rely on `ddl-auto: update` in Production.
- Use versioned migration scripts (e.g., Flyway) for schema changes.

